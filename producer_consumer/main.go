// Вирішення задачі постачальника-споживача з використанням каналів. Код належить Trevor Sawler та підготовлений
// ним в рамках курсу Working with Concurrency in Go (Golang)/Udemy

//Тут я намагався роз'яснити локігу цього коду простими словами. Коментарі - мої власні

// Задача постачальника-споживача (англ. producer-consumer problem), також відома як задача обмеженого буфера 
// (англ. bounded-buffer problem) - це класичний приклад задачі синхронізації кількох процесів. Задача описує
// два процеси, постачальник і споживач, які спільно використовують буфер встановленого розміру. Завданням
// постачальника є створення фрагменту даних, запис його до буфера і повторення цих дій раз за разом. Одночасно
// з цим споживач споживає дані (тобто, видаляє їх з буфера) по одному фрагменту за раз. Задача полягає в тому,
// щоб не дати постачальнику записати дані, коли буфер повний, а споживачу не дати видалити дані з порожнього буфера
// - Wikipedia

// Для досягнення нашої мети ми візьмемо умовну піцерію, яка виконує певну завчасно визначену кількість замовлень з
// виготовлення піци. Час виготовлення та успішність визначається рандомно - для цього використовується пакет math/rand.
// Пакет github.com/fatih/color використовується для виводу в термінал інформації в кольорі.

// Ми не використовуємо пакет sync/mutex, натомість використовуються канали. Звареніть увагу, що в процесі виконання
// програми будуть паралельно виконуватись main-функція, в якій буде працювати наш Споживач та горутина, яка
// представляє собою діяльність Постачальника

package main

import (
	"fmt"
	"math/rand"
	"time"

	"github.com/fatih/color"
)

// Константою визначаємо кількість піц, які необхідно виготовити
const NumberOfPizzas = 10

// Визначаємо каунтери, які будуть рахувати кількість успішно виготовлених піц, кількість неуспішних спроб та
// загальну кількість, яка має відповідати сумі каунтерів та вишевизначеній константі NumberOfPizzas
var pizzasMade, pizzasFailed, total int

// Створюємо стурктуру нашого Постачальника. Вона містить тільки 2 канали. Перший канал - data - призначений
// для отримання структури PizzaOrder, яку ми оголошуємо після цього. Через цей канал ми власне будемо отримувати
// інформацію про замовлення, які нам надходять. Другий канал - призначений для закриття обох каналів, бо відкриті
// канали потребують закриття коли вони стають непотрібними. Go дозволяє нам створювати канал для каналів.
// На мою думку тут не обов'язково використовувати саме канал каналів, так само тут могла б бути пуста структура,
// бо єдиний сенс існування цього каналу - отримання сигналу про необхідність припинення роботи Постачальника і закриття відкритих каналів
type Producer struct {
	data chan PizzaOrder
	quit chan chan error
}

// Імплементує наше замовлення, але скоріше - одразу результат замовлення. Відповідно pizzaNumber - порядковий номер замовлення. В нас він буде починатись від 1 і закінчуватись
// номером, рівним константі NumberOfPizzas. Поле message буде зберігати повідомлення про результати виготовлення замовлення, а поле
// success - успішний чи не успішний результат. Останні два поля призначені скоріше прикрасити нашу програму, та не відіграють роль у
// у досягеннні мети задачі
type PizzaOrder struct {
	pizzaNumber int
	message     string
	success     bool
}

// Close - метод структури Producer. ЇЇ єдина мета - відправити в канал quit нашої структури Producer канал типу error, що буде сигналом
// до закінчення роботи Постачальника. В даному випадку через сам створений канал ch нічого проходити не буде. Тому команда return <-ch
// іколи не поверне помилку. Тому на мою думку цей метод може бути спрощено. Окрім того, повторюсь, на мою думку тут може бути використано
// пусту структуру.
func (p *Producer) Close() error {
	ch := make(chan error)
	p.quit <- ch
	return <-ch
}

// функція призначена для створення поінтеру на екземпляр структури PizzaOrder. Функція приймає int, який означає номер попереднього замовлення.
func makePizza(pizzaNumber int) *PizzaOrder {
	// Першим отриманим значенням pizzaNumber буде 0. Ми одразу інкрементуємо це значення. Таким чином, перше замовлення буде мати номер 1.
	pizzaNumber++
	// Ми перевіряємо, чи ми ще не вийшли за кількість, визначену константою NumberOfPizzas
	if pizzaNumber <= NumberOfPizzas {
		// Визначаємо рандомне число від 1 до 6, яке використаємо трохи далі для визначення тривалості виготовлення піци
		delay := rand.Intn(5) + 1
		// Повідомляємо про отримання замовлення та його номер
		fmt.Printf("Received order #%d!\n", pizzaNumber)

		// Визначаємо рандомне число від 1 до 13, яке використаємо для визначення успішності чи неуспішності виготовлення піци
		rnd := rand.Intn(12) + 1
		// оголошуємо змінну msg, за замовчуванням - пуста строка
		msg := ""
		// оголошуємо змінну success, за замовчуванням - false
		success := false

		// Якщо наше число менше 5 - визначємо, що замовлення не виконано
		if rnd < 5 {
			// та інкрементуємо лічильник неуспішних замовлень
			pizzasFailed++
		} else {
			// інакше - виконано, та інкрементуємо лічильник успішних замовлень
			pizzasMade++
		}
		// незалежно від успіху інкрементуємо загальний лічіильник замовлень
		total++

		// Повідомляємо про час, потрібний для виготовлення замовлення та його номер
		fmt.Printf("Making pizza #%d. It will take %d seconds.....\n", pizzaNumber, delay)

		// Тут фактично ми витрачаємо час на очікування замовлення. Термін, який ми очікуємо був попередньо рандомно визначений в змінній delay
		time.Sleep(time.Duration(delay) * time.Second)

		// Заповнюємо нашу зміну msg повідомленням, яке визначаємо на основі змінної rnd. Фактично в коді ми двічі викорситовуємо її: перший
		// раз для лічильника, а другий раз для визначення повідомлення та статусу успішності. На мій погляд очевидно необхідним є поєднання
		// цих двох випадків в один.
		if rnd <=2 {
			msg = fmt.Sprintf("*** We ran out of ingradients for pizza #%d!\n", pizzaNumber)
		} else if rnd <= 4 {
			msg = fmt.Sprintf("*** The cook quit while making pizza #%d!\n", pizzaNumber)
		} else {
			// Сюди ми попадаємо тільки якщо виготовлення піци було успішним, тому змінюємо змінну success на true
			success = true
			msg = fmt.Sprintf("Pizza order #%d is ready!\n", pizzaNumber)
		}

		//Створюємо екземпляр структури PizzaOrder та заповнюємо її поля відповдіними даими: номер замовлення, повідомлення та статус успішності
		p := PizzaOrder{
			pizzaNumber: pizzaNumber,
			message: msg,
			success: success,
		}

		//Вертаємо поінтер на структуру
		return &p

	} 
	
	// Сюди ми попадаємо тільки в тому випадку, коли ми вийшли за межі нашої константи NumberOfPizzas, яка визначала максимальну кількість піц.
	// В такому випадку ми повертаємо поінтер на структуру PizzaOrder, яка містить тільки поле з номером замовлення  
	return &PizzaOrder{
		pizzaNumber: pizzaNumber,
	}

}

// Функція pizzeria представляє собою діяльність нашого Постачальника і приймає поінтер на нього як аргумент, тому, на мою думку, доцільніше,
// щоб це був метод структури Producer
func pizzeria(pizzaMaker *Producer) {
	// Ми починаємо відлік замовлень з 0.
	var i = 0

	// в безкінченому циклі ми починаємо виконвати функцію makePizza, яка прйимає як аргумент змінну i, яка веде облік замовлень.
	for {
		currentPizza := makePizza(i)

		// Ми перевіряємо, чи не отримали ми nil замість поінтера на структуру. Але насправді така перевірка не має сенсу, оскільки відстуні випадки,
		// коли б функція makePizza могла повернути nil
		if currentPizza != nil {

			// Нагадую, що в середині функції makePizza значення i одразу інкрементується і призначається полю pizzaNumber. Тепер ми звертаємось до
			// цього поля і його значення присвоюємо змінній i, таким чином воно також інкрементується
			i = currentPizza.pizzaNumber

			// Наступна частина коду представляє собою конструкцію select, яка використовується для обробки одного або кількох каналів в залежності від
			// того, який канал готовий до взаємодії. Ми ще не розглядали код, який буде впливати на поведінку цієї конструкції - він буде трошки пізніше.
			// Головне, що потрібно розуміти, що з самого початку відправити дані в канал data можливо, а от прочитати з каналу quit - ні, бо він пустий.
			// Тому поки ми виконуємо замовлення і не вийшли за ліміти константи - виконується перший випадок case. В подальшому це зміниться, і буде виконано
			// другий випадок case
			select {

				// В цьому випадку ми перевріяємо, чи можливо відправити дані (а саме поінтер на екземпляр *PizzaOrder)в канал data нашого Постачальника.
				// Фактично ми і здійснюємо таку відправку, якщо є відповідна можливість
			case pizzaMaker.data <- *currentPizza:

				// Тут ми перевіряємо, чи можливо отримати дані з каналу quit, якщо так - ми закриваємо канал data нашого Постачальника та канал quitChan,
				// який ми прямо тут створили для отримання даних з каналу quit нашого Постачальника. \Після цього ми виходимо із функції pizzeria
			case quitChan := <- pizzaMaker.quit:
				close(pizzaMaker.data)
				close(quitChan)
				return
			}
		}
	}
}

// Починаємо виконання нашої головної функції
func main() {
	// Виводимо повідомлення про початок роботи
	color.Cyan(" ------------------------------------ ")
	color.Cyan("| The Pizzeria is open for business! |")
	color.Cyan(" ------------------------------------ ")

	// Створюємо посилання на екземпляр струткури Producer
	pizzaJob := &Producer{
		data: make(chan PizzaOrder),
		quit: make(chan chan error),
	}

	// В горутині запускаємо функцію pizzeria, яка символізує процес роботи Постачальника
	go pizzeria(pizzaJob)

	// Наступний цикл символізцє процес роботи Споживача. Ми постійно читаємо дані з каналу data структури Producer
	for i := range pizzaJob.data {

		// Перевіряємо чи не вийшли ми за ліміти і далі виводимо інформацію про замовлення в залежності від успішності його виконання
		if i.pizzaNumber <= NumberOfPizzas {
			if i.success {
				color.Green(i.message)
				color.Green("Order #%d is out for delivery!", i.pizzaNumber)
			} else {
				color.Red(i.message)
				color.Red("The customer is really mad")
			}
		} else {

			// Якщо номер нашого замовлення більше ніж значення, визначене константою NumberOfPizzas, виводимо повідомлення про
			// закінчення роботи і викликаємо метод структури Producer, який створює chan error і направляє його в канад quit структури
			// Producer, що є сигналом для закінчення програми
			color.Cyan("Done making pizzas....")
			err := pizzaJob.Close()
			if err != nil {
				color.Red("*** Error closing channel!", err)
			}
		}
	}

	// Виводимо інформацію про закінчення роботи, а також підводимо підсумки виконання замовлень.
	color.Cyan("--------------------")
	color.Cyan("| Done for the day |")
	color.Cyan("--------------------")

	color.Cyan("We made %d pizzas, but failed to make %d, with %d attemps in total.", pizzasMade, pizzasFailed, total)

	switch {
	case pizzasFailed > 9:
		color.Red("It was an awful day...")
	case pizzasFailed >= 6:
		color.Red("It was not a very good day...")
	case pizzasFailed >= 4:
		color.Yellow("It was an Ok day...")
	case pizzasFailed >= 2:
		color.Yellow("It was a pretty good day!")
	default:
		color.Green("It was a great day!")
	}
}
